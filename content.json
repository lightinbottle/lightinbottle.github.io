[{"title":"","date":"2017-05-21T09:22:49.782Z","path":"2017/05/21/Binary-Algorithm/","text":"二分算法标签（空格分隔）： 算法 面试 ##算法介绍二分算法最简单的体现是在一个有序的数组中查找某一个元素，如果元素存在就返回元素的位置（索引）如果不存在返回-1，也叫二分查找 二分查找的java代码如下：12345678910111213private static find(int[] a,int n,int x)&#123; int left=0,right=n-1; while(left!=right)&#123; int mid=(left+right)/2; if(a[mid]==x) return mid; else if(a[mid]&lt;x) left=mid+1; else(a[mid]&gt;x) right=mid-1; &#125; return a[left]==x?left:-1;&#125; 二分的前提条件或者本质是有序 ##二分的应用下面是一道面试题： 给定长度为n的数组a和长度为m的数组b，以及一个数s，统计有多少对(0 ≤ i &lt; n, 0 ≤ j &lt; m)满足a[i] + b[j] ≤ s 最基础的方法是暴力枚举，算法复杂度是O(mn) 利用二分法的方法也就是先将b数组排序，我们做一下表达式的变换，a[i] + b[j] ≤ s 变成 b[j] &lt;= s - a[i]，意思就是对于一个给定的a[i]，你要统计一下b数组中有多少个数小于等于s - a[i]。 java代码如下：123456789101112131415161718private static long binarySearch()&#123; Arrays.sort(b); long count=0; for(int i=0;i&lt;n;++i)&#123; long t=(long)s-a[i]; int left=0,right=m; while(left+1&lt;right)&#123; int mid=(left+right)/2; if(b[mid]&lt;=t) left=mid; else right=mid; &#125; if(b[left]&lt;=t) count+=left+1; &#125; return count;&#125; 算法复杂度O(mlogn)##通用二分法的流程 确定mid检查条件（b[mid] &lt;= t） 确定求最大还是最小，最大：left = mid，答案是left，[left, right)；最小：right =mid，答案是right，(left, right] 根据2确定初始范围 检查最终答案是否满足条件（b[left] &lt;= t） ##学长整理公众号整理公众号整理","tags":[]},{"title":"Hello World","date":"2017-05-21T04:58:03.963Z","path":"2017/05/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]